import os
import json
from datetime import datetime

# Importar conexão Oracle do projeto
try:
    from conecxaodb import get_connection
except ImportError:
    import sys
    sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..')))
    from conecxaodb import get_connection

def get_db_connection():
    """Obtém uma conexão com o Oracle"""
    return get_connection()

def init_db():
    """Garante que as tabelas necessárias existam no Oracle"""
    conn = get_db_connection()
    if not conn: return
    cursor = conn.cursor()
    
    try:
        # Tabela de Alertas
        cursor.execute('''
        BEGIN
            EXECUTE IMMEDIATE 'CREATE TABLE SYSROH.TB_AI_ALERTS (
                ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                USER_NAME VARCHAR2(100) NOT NULL,
                TITLE VARCHAR2(200) NOT NULL,
                SQL_QUERY CLOB NOT NULL,
                CONDITION_TYPE VARCHAR2(50),
                THRESHOLD_VALUE VARCHAR2(100),
                STATUS VARCHAR2(20) DEFAULT ''PENDING'',
                CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )';
        EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF;
        END;
        ''')

        # Tabela de Predições
        cursor.execute('''
        BEGIN
            EXECUTE IMMEDIATE 'CREATE TABLE SYSROH.TB_AI_PREDICTIONS (
                ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                USER_NAME VARCHAR2(100) NOT NULL,
                TARGET_DATA VARCHAR2(200),
                FORECAST_JSON CLOB,
                CONFIDENCE_SCORE NUMBER,
                CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )';
        EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF;
        END;
        ''')

        # Tabela de Chats
        cursor.execute('''
        BEGIN
            EXECUTE IMMEDIATE 'CREATE TABLE SYSROH.TB_AI_CHATS (
                ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                USER_NAME VARCHAR2(100) NOT NULL,
                TITLE VARCHAR2(200) DEFAULT ''Nova Conversa'',
                CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )';
        EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF;
        END;
        ''')

        # Tabela de Mensagens
        cursor.execute('''
        BEGIN
            EXECUTE IMMEDIATE 'CREATE TABLE SYSROH.TB_AI_MESSAGES (
                ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                CHAT_ID NUMBER NOT NULL,
                ROLE VARCHAR2(20) NOT NULL,
                CONTENT CLOB NOT NULL,
                METADATA CLOB,
                CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                CONSTRAINT FK_AI_MSG_CHAT FOREIGN KEY (CHAT_ID) REFERENCES SYSROH.TB_AI_CHATS(ID) ON DELETE CASCADE
            )';
        EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF;
        END;
        ''')

        # Tabela de Favoritos
        cursor.execute('''
        BEGIN
            EXECUTE IMMEDIATE 'CREATE TABLE SYSROH.TB_AI_FAVORITES (
                ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                USER_NAME VARCHAR2(100) NOT NULL,
                QUERY_TEXT CLOB NOT NULL,
                TITLE VARCHAR2(200),
                CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )';
        EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF;
        END;
        ''')

        # Tabela de Padrões de Usuário (Auto-complete)
        cursor.execute('''
        BEGIN
            EXECUTE IMMEDIATE 'CREATE TABLE SYSROH.TB_AI_USER_PATTERNS (
                ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                USER_NAME VARCHAR2(100) NOT NULL,
                QUERY_TEXT VARCHAR2(500) NOT NULL,
                FREQUENCY NUMBER DEFAULT 1,
                LAST_USED TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                CONSTRAINT UNQ_AI_USER_QUERY UNIQUE (USER_NAME, QUERY_TEXT)
            )';
        EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF;
        END;
        ''')

        conn.commit()
    except Exception as e:
        print(f"Erro ao inicializar tabelas de histórico no Oracle: {e}")
    finally:
        cursor.close()
        conn.close()

# --- Funções para Alertas ---
def add_alert(user_name, title, sql_query, condition_type, threshold_value):
    conn = get_db_connection()
    if not conn: return
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO SYSROH.TB_AI_ALERTS (USER_NAME, TITLE, SQL_QUERY, CONDITION_TYPE, THRESHOLD_VALUE)
        VALUES (:user_name, :title, :sql_query, :condition_type, :threshold_value)
    ''', {
        'user_name': user_name, 
        'title': title, 
        'sql_query': sql_query, 
        'condition_type': condition_type, 
        'threshold_value': threshold_value
    })
    conn.commit()
    cursor.close()
    conn.close()

def get_alerts(user_name):
    conn = get_db_connection()
    if not conn: return []
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM SYSROH.TB_AI_ALERTS WHERE USER_NAME = :user_name ORDER BY CREATED_AT DESC', {'user_name': user_name})
    
    col_names = [description[0].lower() for description in cursor.description]
    alerts = []
    for row in cursor.fetchall():
        row_dict = dict(zip(col_names, row))
        # Ler CLOBs se necessário
        for k, v in row_dict.items():
            if hasattr(v, 'read'):
                row_dict[k] = v.read()
        alerts.append(row_dict)
        
    cursor.close()
    conn.close()
    return alerts

def update_alert_status(alert_id, status):
    conn = get_db_connection()
    if not conn: return
    cursor = conn.cursor()
    cursor.execute('UPDATE SYSROH.TB_AI_ALERTS SET STATUS = :status WHERE ID = :alert_id', {'status': status, 'alert_id': alert_id})
    conn.commit()
    cursor.close()
    conn.close()

def delete_alert(alert_id):
    conn = get_db_connection()
    if not conn: return
    cursor = conn.cursor()
    cursor.execute('DELETE FROM SYSROH.TB_AI_ALERTS WHERE ID = :alert_id', {'alert_id': alert_id})
    conn.commit()
    cursor.close()
    conn.close()

# --- Funções para Predições ---
def save_prediction(user_name, target, forecast_json, confidence):
    conn = get_db_connection()
    if not conn: return
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO SYSROH.TB_AI_PREDICTIONS (USER_NAME, TARGET_DATA, FORECAST_JSON, CONFIDENCE_SCORE)
        VALUES (:user_name, :target, :forecast_json, :confidence)
    ''', {
        'user_name': user_name, 
        'target': target, 
        'forecast_json': json.dumps(forecast_json), 
        'confidence': confidence
    })
    conn.commit()
    cursor.close()
    conn.close()

def get_predictions(user_name):
    conn = get_db_connection()
    if not conn: return []
    cursor = conn.cursor()
    cursor.execute('''
        SELECT * FROM (
            SELECT * FROM SYSROH.TB_AI_PREDICTIONS 
            WHERE USER_NAME = :user_name 
            ORDER BY CREATED_AT DESC
        ) WHERE ROWNUM <= 10
    ''', {'user_name': user_name})
    
    col_names = [description[0].lower() for description in cursor.description]
    preds = []
    for row in cursor.fetchall():
        row_dict = dict(zip(col_names, row))
        # Ler CLOBs
        for k, v in row_dict.items():
            if hasattr(v, 'read'):
                row_dict[k] = v.read()
        preds.append(row_dict)
        
    cursor.close()
    conn.close()
    return preds

# Funções CRUD para Chats
def create_chat(user_name, title='Nova Conversa'):
    conn = get_db_connection()
    if not conn: return None
    cursor = conn.cursor()
    
    # No Oracle, pegamos o ID gerado usando RETURNING
    id_var = cursor.var(int)
    cursor.execute('''
        INSERT INTO SYSROH.TB_AI_CHATS (USER_NAME, TITLE) 
        VALUES (:user_name, :title)
        RETURNING ID INTO :id
    ''', {'user_name': user_name, 'title': title, 'id': id_var})
    
    chat_id = id_var.getvalue()[0]
    conn.commit()
    cursor.close()
    conn.close()
    return chat_id

def get_user_chats(user_name):
    conn = get_db_connection()
    if not conn: return []
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM SYSROH.TB_AI_CHATS WHERE USER_NAME = :user_name ORDER BY UPDATED_AT DESC', {'user_name': user_name})
    
    col_names = [description[0].lower() for description in cursor.description]
    chats = []
    for row in cursor.fetchall():
        row_dict = dict(zip(col_names, row))
        # Ler CLOBs
        for k, v in row_dict.items():
            if hasattr(v, 'read'):
                row_dict[k] = v.read()
        chats.append(row_dict)
        
    cursor.close()
    conn.close()
    return chats

def get_chat_messages(chat_id):
    conn = get_db_connection()
    if not conn: return []
    cursor = conn.cursor()
    cursor.execute('SELECT ROLE, CONTENT, METADATA FROM SYSROH.TB_AI_MESSAGES WHERE CHAT_ID = :chat_id ORDER BY CREATED_AT ASC', {'chat_id': chat_id})
    
    col_names = [description[0].lower() for description in cursor.description]
    messages = []
    for row in cursor.fetchall():
        msg = dict(zip(col_names, row))
        
        # Ler CLOBs
        for k, v in msg.items():
            if hasattr(v, 'read'):
                msg[k] = v.read()
                
        if msg.get('metadata'):
            try:
                msg['metadata'] = json.loads(msg['metadata'])
                if isinstance(msg['metadata'], dict):
                    for k, v in msg['metadata'].items():
                        msg[k] = v
            except:
                pass
        messages.append(msg)
        
    cursor.close()
    conn.close()
    return messages

def add_message(chat_id, role, content, metadata=None):
    conn = get_db_connection()
    if not conn: return
    cursor = conn.cursor()
    meta_json = json.dumps(metadata) if metadata else None
    
    cursor.execute('''
        INSERT INTO SYSROH.TB_AI_MESSAGES (CHAT_ID, ROLE, CONTENT, METADATA) 
        VALUES (:chat_id, :role, :content, :metadata)
    ''', {
        'chat_id': chat_id, 
        'role': role, 
        'content': content, 
        'metadata': meta_json
    })
    
    cursor.execute('UPDATE SYSROH.TB_AI_CHATS SET UPDATED_AT = CURRENT_TIMESTAMP WHERE ID = :chat_id', {'chat_id': chat_id})
    
    conn.commit()
    cursor.close()
    conn.close()

def delete_chat(chat_id):
    conn = get_db_connection()
    if not conn: return
    cursor = conn.cursor()
    # No Oracle com ON DELETE CASCADE, as mensagens serão removidas automaticamente se a FK estiver configurada assim
    cursor.execute('DELETE FROM SYSROH.TB_AI_CHATS WHERE ID = :chat_id', {'chat_id': chat_id})
    conn.commit()
    cursor.close()
    conn.close()

def update_chat_title(chat_id, title):
    conn = get_db_connection()
    if not conn: return
    cursor = conn.cursor()
    cursor.execute('UPDATE SYSROH.TB_AI_CHATS SET TITLE = :title WHERE ID = :chat_id', {'title': title, 'chat_id': chat_id})
    conn.commit()
    cursor.close()
    conn.close()

# Funções para Favoritos
def add_favorite(user_name, query, title):
    conn = get_db_connection()
    if not conn: return
    cursor = conn.cursor()
    cursor.execute('INSERT INTO SYSROH.TB_AI_FAVORITES (USER_NAME, QUERY_TEXT, TITLE) VALUES (:user_name, :query, :title)', {
        'user_name': user_name, 
        'query': query, 
        'title': title
    })
    conn.commit()
    cursor.close()
    conn.close()

def get_favorites(user_name):
    conn = get_db_connection()
    if not conn: return []
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM SYSROH.TB_AI_FAVORITES WHERE USER_NAME = :user_name ORDER BY CREATED_AT DESC', {'user_name': user_name})
    
    col_names = [description[0].lower() for description in cursor.description]
    favs = []
    for row in cursor.fetchall():
        row_dict = dict(zip(col_names, row))
        # Ler CLOBs
        for k, v in row_dict.items():
            if hasattr(v, 'read'):
                row_dict[k] = v.read()
        favs.append(row_dict)
        
    cursor.close()
    conn.close()
    return favs

def delete_favorite(fav_id):
    conn = get_db_connection()
    if not conn: return
    cursor = conn.cursor()
    cursor.execute('DELETE FROM SYSROH.TB_AI_FAVORITES WHERE ID = :fav_id', {'fav_id': fav_id})
    conn.commit()
    cursor.close()
    conn.close()

# Funções para Auto-complete / Sugestões
def record_user_query(user_name, query):
    if not query or len(query) < 3: return
    conn = get_db_connection()
    if not conn: return
    cursor = conn.cursor()
    
    # Usar MERGE para "INSERT OR UPDATE"
    sql = """
        MERGE INTO SYSROH.TB_AI_USER_PATTERNS t
        USING (SELECT :uname as un, :q as query FROM dual) s
        ON (t.USER_NAME = s.un AND t.QUERY_TEXT = s.query)
        WHEN MATCHED THEN
            UPDATE SET FREQUENCY = FREQUENCY + 1, LAST_USED = CURRENT_TIMESTAMP
        WHEN NOT MATCHED THEN
            INSERT (USER_NAME, QUERY_TEXT, FREQUENCY) VALUES (:uname, :q, 1)
    """
    cursor.execute(sql, {'uname': user_name, 'q': query})
    conn.commit()
    cursor.close()
    conn.close()

def get_suggestions(user_name, partial_query=''):
    conn = get_db_connection()
    if not conn: return []
    cursor = conn.cursor()
    
    if partial_query:
        sql = """
            SELECT * FROM (
                SELECT QUERY_TEXT FROM SYSROH.TB_AI_USER_PATTERNS 
                WHERE USER_NAME = :user_name AND QUERY_TEXT LIKE :q 
                ORDER BY FREQUENCY DESC
            ) WHERE ROWNUM <= 5
        """
        cursor.execute(sql, {'user_name': user_name, 'q': f'%{partial_query}%'})
    else:
        sql = """
            SELECT * FROM (
                SELECT QUERY_TEXT FROM SYSROH.TB_AI_USER_PATTERNS 
                WHERE USER_NAME = :user_name 
                ORDER BY FREQUENCY DESC
            ) WHERE ROWNUM <= 5
        """
        cursor.execute(sql, {'user_name': user_name})
    
    suggestions = [row[0] for row in cursor.fetchall()]
    cursor.close()
    conn.close()
    return suggestions

# Inicializa o banco ao carregar o módulo
init_db()
